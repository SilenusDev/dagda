{
  "manifest": {
    "name": "merge-anything",
    "version": "5.1.7",
    "description": "Merge objects & other types recursively. A simple & small integration.",
    "type": "module",
    "sideEffects": false,
    "types": "./dist/index.d.ts",
    "module": "./dist/index.js",
    "main": "./dist/index.js",
    "exports": {
      ".": {
        "require": {
          "types": "./dist/cjs/index.d.cts",
          "default": "./dist/cjs/index.cjs"
        },
        "import": {
          "types": "./dist/index.d.ts",
          "default": "./dist/index.js"
        }
      }
    },
    "files": [
      "dist"
    ],
    "engines": {
      "node": ">=12.13"
    },
    "scripts": {
      "lint": "tsc --noEmit && eslint ./src --ext .ts",
      "test": "vitest run",
      "build": "rollup -c ./rollup.config.js",
      "release": "npm run lint && del dist && npm run build && np"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/mesqueeb/merge-anything.git"
    },
    "keywords": [
      "javascript",
      "merge",
      "deepmerge",
      "recursively",
      "object-assign",
      "deep-assign",
      "nested-assign",
      "typescript",
      "deep-merge",
      "merge-object",
      "merge-objects",
      "deep-merge-object",
      "object-assign-deep",
      "nested-object-assign",
      "nested-merge",
      "combine",
      "combine-objects",
      "combine-merge",
      "merge-combine",
      "nested-combine"
    ],
    "author": {
      "name": "Luca Ban - Mesqueeb"
    },
    "funding": "https://github.com/sponsors/mesqueeb",
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/mesqueeb/merge-anything/issues"
    },
    "homepage": "https://github.com/mesqueeb/merge-anything#readme",
    "dependencies": {
      "is-what": "^4.1.8"
    },
    "devDependencies": {
      "@typescript-eslint/eslint-plugin": "^5.59.2",
      "@typescript-eslint/parser": "^5.59.2",
      "del-cli": "^5.0.0",
      "eslint": "^8.40.0",
      "eslint-config-prettier": "^8.8.0",
      "eslint-plugin-tree-shaking": "^1.10.0",
      "np": "^7.7.0",
      "prettier": "^2.8.8",
      "rollup": "^3.23.0",
      "rollup-plugin-dts": "^5.3.0",
      "rollup-plugin-esbuild": "^5.0.0",
      "typescript": "^5.0.4",
      "vitest": "^0.31.0"
    },
    "np": {
      "yarn": false,
      "branch": "production"
    },
    "eslintConfig": {
      "ignorePatterns": [
        "node_modules",
        "dist",
        "scripts",
        "test"
      ],
      "root": true,
      "parser": "@typescript-eslint/parser",
      "plugins": [
        "@typescript-eslint",
        "tree-shaking"
      ],
      "extends": [
        "eslint:recommended",
        "plugin:@typescript-eslint/eslint-recommended",
        "plugin:@typescript-eslint/recommended",
        "prettier"
      ],
      "rules": {
        "@typescript-eslint/no-empty-function": "off",
        "@typescript-eslint/no-explicit-any": "off",
        "@typescript-eslint/ban-ts-ignore": "off",
        "tree-shaking/no-side-effects-in-initialization": "error",
        "@typescript-eslint/ban-ts-comment": "off"
      }
    },
    "_registry": "npm",
    "_loc": "/yarn-cache/v6/npm-merge-anything-5.1.7-94f364d2b0cf21ac76067b5120e429353b3525d7-integrity/node_modules/merge-anything/package.json",
    "readmeFilename": "README.md",
    "readme": "# Merge anything ü•°\n\n<a href=\"https://www.npmjs.com/package/merge-anything\"><img src=\"https://img.shields.io/npm/v/merge-anything.svg\" alt=\"Total Downloads\"></a>\n<a href=\"https://www.npmjs.com/package/merge-anything\"><img src=\"https://img.shields.io/npm/dw/merge-anything.svg\" alt=\"Latest Stable Version\"></a>\n\n```\nnpm i merge-anything\n```\n\nMerge objects & other types recursively. Fully **TypeScript** supported! A simple & small integration.\n\n## Motivation\n\nI created this package because I tried a lot of similar packages that do merging/deepmerging/recursive object assign etc. But all had its quirks, and _all of them break things they are not supposed to break_... üòû\n\nI was looking for:\n\n- a simple merge function like `Object.assign()` but deep\n- supports merging of nested properties\n- supports TypeScript: the type of the result is what JS actually returns\n- supports symbols\n- supports enumerable & nonenumerable props\n- **does not break special class instances**„ÄÄ‚ÄºÔ∏è\n\nThis last one is crucial! In JavaScript almost everything is _an object_, sure, but I don't want a merge function trying to merge eg. two `new Date()` instances! So many libraries use custom classes that create objects with special prototypes, and such objects all break when trying to merge them. So we gotta be careful!\n\nmerge-anything will merge objects and nested properties, but only as long as they're \"plain objects\". As soon as a sub-prop is not a \"plain object\" and has a special prototype, it will copy that instance over \"as is\". ‚ôªÔ∏è\n\n## Meet the family (more tiny utils with TS support)\n\n- [is-what üôâ](https://github.com/mesqueeb/is-what)\n- [is-where üôà](https://github.com/mesqueeb/is-where)\n- [merge-anything ü•°](https://github.com/mesqueeb/merge-anything)\n- [check-anything üëÅ](https://github.com/mesqueeb/check-anything)\n- [remove-anything ‚úÇÔ∏è](https://github.com/mesqueeb/remove-anything)\n- [getorset-anything üêä](https://github.com/mesqueeb/getorset-anything)\n- [map-anything üó∫](https://github.com/mesqueeb/map-anything)\n- [filter-anything ‚öîÔ∏è](https://github.com/mesqueeb/filter-anything)\n- [copy-anything üé≠](https://github.com/mesqueeb/copy-anything)\n- [case-anything üê´](https://github.com/mesqueeb/case-anything)\n- [flatten-anything üèè](https://github.com/mesqueeb/flatten-anything)\n- [nestify-anything üßÖ](https://github.com/mesqueeb/nestify-anything)\n\n## Usage\n\n- Unlimited ‚Äî Merge will merge an unlimited amount of plain objects you pass as the arguments\n- Nested ‚Äî Nested objects are merged deeply (see example below)\n- No modification ‚Äî Merge always returns a new object without modifying the original, but does keep object/array references for nested props (see [#A note on JavaScript object references](#a-note-on-javascript-object-references))\n\n```js\nimport { merge } from 'merge-anything'\n\nconst starter = { name: 'Squirtle', types: { water: true } }\nconst newValues = { name: 'Wartortle', types: { fighting: true }, level: 16 }\n\nconst evolution = merge(starter, newValues, { is: 'cool' })\n// returns {\n//   name: 'Wartortle',\n//   types: { water: true, fighting: true },\n//   level: 16,\n//   is: 'cool'\n// }\n```\n\n## TypeScript Support\n\nIn the example above, if you are using TypeScript, and you hover over `evolution`, you can actually see the type of your new object right then and there. This is very powerful, because you can merge things, and without needing `any`, TypeScript will know exactly how your newly merged objects look!\n\n![typescript support](https://raw.githubusercontent.com/mesqueeb/merge-anything/master/.github/typescript-support.png)\n\nThe return type of the `merge()` function is usable as a TypeScript utility as well:\n\n```ts\nimport type { Merge } from 'merge-anything'\n\ntype A1 = { name: string }\ntype A2 = { types: { water: boolean } }\ntype A3 = { types: { fighting: boolean } }\n\ntype Result = Merge<A1, [A2, A3]>\n```\n\n## Rules\n\nThis package will recursively go through plain objects and merge the values onto a new object.\n\n> Please note that this package recognises special JavaScript objects like class instances. In such cases it will not recursively merge them like objects, but assign the class onto the new object \"as is\"!\n\n```js\n// all passed objects do not get modified\nconst a = { a: 'a' }\nconst b = { b: 'b' }\nconst c = { c: 'c' }\nconst result = merge(a, b, c)\n// a === {a: 'a'}\n// b === {b: 'b'}\n// c === {c: 'c'}\n// result === {a: 'a', b: 'b', c: 'c'}\n// However, be careful with JavaScript object references with nested props. See below: A note on JavaScript object references\n\n// arrays get overwritten\n// (for \"concat\" logic, see Extensions below)\nmerge({ array: ['a'] }, { array: ['b'] }) // returns {array: ['b']}\n\n// empty objects merge into objects\nmerge({ obj: { prop: 'a' } }, { obj: {} }) // returns {obj: {prop: 'a'}}\n\n// but non-objects overwrite objects\nmerge({ obj: { prop: 'a' } }, { obj: null }) // returns {obj: null}\n\n// and empty objects overwrite non-objects\nmerge({ prop: 'a' }, { prop: {} }) // returns {prop: {}}\n```\n\nmerge-anything properly keeps special objects intact like dates, regex, functions, class instances etc.\n\nHowever, it's **very important** you understand how to work around JavaScript object references. Please be sure to read [#a note on JavaScript object references](#a-note-on-javascript-object-references) down below.\n\n## Concat arrays\n\nThe default behaviour is that arrays are overwritten. You can import `mergeAndConcat` if you need to concatenate arrays. But don't worry if you don't need this, this library is tree-shakable and won't import code you don't use!\n\n<!-- prettier-ignore-start -->\n```js\nimport { mergeAndConcat } from 'merge-anything'\n\nmergeAndConcat(\n  { nested: { prop: { array: ['a'] } } },\n  { nested: { prop: { array: ['b'] } } }\n)\n// returns { nested: { prop: { array: ['a', 'b'] } } },\n```\n<!-- prettier-ignore-end -->\n\n## Compare Function when a value is merged\n\nThere might be times you need to tweak the logic when two things are merged. You can provide your own custom function that's triggered every time a value is overwritten.\n\nFor this case we use `mergeAndCompare`. Here is an example with a compare function that concatenates strings:\n\n```js\nimport { mergeAndCompare } from 'merge-anything'\n\nfunction concatStrings(originVal, newVal, key) {\n  if (typeof originVal === 'string' && typeof newVal === 'string') {\n    // concat logic\n    return `${originVal}${newVal}`\n  }\n  // always return newVal as fallback!!\n  return newVal\n}\n\nmergeAndCompare(concatStrings, { name: 'John' }, { name: 'Simth' })\n// returns { name: 'JohnSmith' }\n```\n\n> Note for TypeScript users. The type returned by this function might not be correct. In that case you have to cast the result to your own provided interface\n\n## A note on JavaScript object references\n\nBe careful for JavaScript object reference. Any property that's nested will be reactive and linked between the original and the merged objects! Down below we'll show how to prevent this.\n\n```js\nconst original = { airport: { status: 'dep. üõ´' } }\nconst extraInfo = { airport: { location: 'Brussels' } }\nconst merged = merge(original, extraInfo)\n\n// we change the status from departuring üõ´ to landing üõ¨\nmerged.airport.status = 'lan. üõ¨'\n\n// the `merged` value will be modified\n// merged.airport.status === 'lan. üõ¨'\n\n// However `original` value will also be modified!!\n// original.airport.status === 'lan. üõ¨'\n```\n\nThe key rule to remember is:\n\n> Any property that's nested more than 1 level without an overlapping parent property will be reactive and linked in both the merge result and the source\n\nHowever, **there is a really easy solution**. We can just copy the merge result to get rid of any reactivity. For this we can use the [copy-anything](https://github.com/mesqueeb/copy-anything) library. This library also makes sure that _special class instances do not break_, so you can use it without fear of breaking stuff!\n\nSee below how we integrate 'copy-anything':\n\n```js\nimport { copy } from 'copy-anything'\n\nconst original = { airport: { status: 'dep. üõ´' } }\nconst extraInfo = { airport: { location: 'Brussels' } }\nconst merged = copy(merge(original, extraInfo))\n\n// we change the status from departuring üõ´ to landing üõ¨\nmerged.airport.status = 'lan. üõ¨'(merged.airport.status === 'lan. üõ¨')(\n  // true\n  // `original` won't be modified!\n  original.airport.status === 'dep. üõ´'\n) // true\n```\n\nYou can then play around where you want to place the `copy()` function.\n\nCopy Anything is also fully TypeScript supported!\n\n## Source code\n\nIt is literally just going through an object recursively and assigning the values to a new object like below. However, it's wrapped to allow extra params etc. The code below is the basic integration, that will make you understand the basics how it works.\n\n```js\nimport { isPlainObject } from 'is-what'\n\nfunction mergeRecursively(origin, newComer) {\n  if (!isPlainObject(newComer)) return newComer\n  // define newObject to merge all values upon\n  const newObject = isPlainObject(origin)\n    ? Object.keys(origin).reduce((carry, key) => {\n        const targetVal = origin[key]\n        if (!Object.keys(newComer).includes(key)) carry[key] = targetVal\n        return carry\n      }, {})\n    : {}\n  return Object.keys(newComer).reduce((carry, key) => {\n    const newVal = newComer[key]\n    const targetVal = origin[key]\n    // early return when targetVal === undefined\n    if (targetVal === undefined) {\n      carry[key] = newVal\n      return carry\n    }\n    // When newVal is an object do the merge recursively\n    if (isPlainObject(newVal)) {\n      carry[key] = mergeRecursively(targetVal, newVal)\n      return carry\n    }\n    // all the rest\n    carry[key] = newVal\n    return carry\n  }, newObject)\n}\n```\n\n\\* Of course, there are small differences with the actual source code to cope with rare cases & extra features. The actual source code is [here](https://github.com/mesqueeb/merge-anything/blob/master/src/merge.ts).\n",
    "licenseText": "MIT License\n\nCopyright (c) 2018 Luca Ban - Mesqueeb\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/merge-anything/-/merge-anything-5.1.7.tgz#94f364d2b0cf21ac76067b5120e429353b3525d7",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/merge-anything/-/merge-anything-5.1.7.tgz",
    "hash": "94f364d2b0cf21ac76067b5120e429353b3525d7",
    "integrity": "sha512-eRtbOb1N5iyH0tkQDAoQ4Ipsp/5qSR79Dzrz8hEPxRX10RWWR/iQXdoKmBSRCThY1Fh5EhISDtpSc93fpxUniQ==",
    "registry": "npm",
    "packageName": "merge-anything",
    "cacheIntegrity": "sha512-eRtbOb1N5iyH0tkQDAoQ4Ipsp/5qSR79Dzrz8hEPxRX10RWWR/iQXdoKmBSRCThY1Fh5EhISDtpSc93fpxUniQ== sha1-lPNk0rDPIax2BntRIOQpNTs1Jdc="
  },
  "registry": "npm",
  "hash": "94f364d2b0cf21ac76067b5120e429353b3525d7"
}